---
title: "Show HN: Inverting Agent Model (App as Clients, Chat as Server and Reflection)"
url: "https://github.com/RAIL-Suite/RAIL"
source: "Hacker News"
date: "2026-02-03"
score: "11"
author: "ddddazed"
---

# Show HN: Inverting Agent Model (App as Clients, Chat as Server and Reflection)

**Êù•Ê∫ê**: [Hacker News](https://news.ycombinator.com/item?id=46871251) | **ËØÑÂàÜ**: 11 | **‰ΩúËÄÖ**: @ddddazed

## ÂéüÊñáÂÜÖÂÆπ

Title: GitHub - RAIL-Suite/RAIL: Remote Agent Invocation Layer

URL Source: http://github.com/RAIL-Suite/RAIL

Markdown Content:
RAIL (Remote Agent Invocation Layer) Protocol - Project Architecture
--------------------------------------------------------------------

[](http://github.com/RAIL-Suite/RAIL#rail-remote-agent-invocation-layer-protocol---project-architecture)
> **One line of code to make any application AI-controllable**

* * *

1. What is RAIL?
----------------

[](http://github.com/RAIL-Suite/RAIL#1-what-is-rail)
RAIL is a **universal bridge** that connects any application (C#, C++, Python, Node.js) to any LLM (GPT, Claude, Gemini). Instead of rewriting your application, you add **one line of code** and the AI can call your methods directly.

* * *

2. Projects at a Glance
-----------------------

[](http://github.com/RAIL-Suite/RAIL#2-projects-at-a-glance)
| Project | Purpose | Language |
| --- | --- | --- |
| **RailOrchestrator** | Main AI application (UI + LLM routing) | C# / WPF |
| **RailBridge.Native** | Native DLL for cross-language IPC | C# (Native AOT) |
| **RailSDK.Universal** | Client SDK for .NET apps | C# (.NET Standard) |
| **RailSDK** | Analysis & manifest generation tools | C# |
| **RailSDK-Cpp** | Client SDK for C++ apps | C++ |
| **RailSDK-Python** | Client SDK for Python apps | Python |
| **RailSDK-Node** | Client SDK for Node.js apps | TypeScript |
| **RailStudio** | Visual tool for scanning/analyzing apps | C# / WPF |
| **ConvertedProjectExample** | Example applications | C# |

* * *

3. Project Details
------------------

[](http://github.com/RAIL-Suite/RAIL#3-project-details)
### RailOrchestrator

[](http://github.com/RAIL-Suite/RAIL#railorchestrator)
**The Brain** - Main application that users interact with.

*   WPF desktop application (.NET 9)
*   Connects to LLMs (Gemini, OpenAI, Anthropic, Claude)
*   ReAct agent loop for multi-step reasoning
*   Hosts the Named Pipe server for client connections
*   Manages assets (Chips) and tool routing

**Key files:**

*   `Services/Host/HostService.cs` - Named Pipe server
*   `Services/LLMService.cs` - LLM API integration
*   `Services/ReAct/ReActOrchestrator.cs` - Agent loop

* * *

### RailBridge.Native

[](http://github.com/RAIL-Suite/RAIL#railbridgenative)
**The Bridge** - Native DLL that enables cross-language communication.

*   Compiled with Native AOT for C-ABI compatibility
*   Exposes functions callable from any language: 
    *   `RAIL_Ignite()` - Connect to host

*   Uses Named Pipes for IPC

**Target:** Python, C++, Node.js, Rust, Go

* * *

### RailSDK.Universal

[](http://github.com/RAIL-Suite/RAIL#railsdkuniversal)
**The .NET SDK** - Client library for C# applications.

*   .NET Standard 2.0 (compatible with .NET Framework 4.6.1+)
*   Simple API: `RailEngine.Ignite(this)`
*   Auto-discovers methods via reflection
*   Loads `RailBridge.dll` for communication

**Usage:**

// In App.xaml.cs
RailEngine.Ignite(this);

* * *

### RailSDK (RailFactory.Core)

[](http://github.com/RAIL-Suite/RAIL#railsdk-railfactorycore)
**The Toolkit** - Assembly scanning and manifest generation.

Contains:

*   `RuntimeRegistry` - Detect .NET / Native binaries
*   `AssemblyScanner` - Extract methods from DLLs
*   `CompositeManifest` - Multi-module manifest format
*   `DependencyAnalyzer` - Analyze project dependencies
*   `SolutionScanner` - Scan entire .sln solutions

**Used by:** RailStudio, RailOrchestrator

* * *

### RailSDK-Cpp

[](http://github.com/RAIL-Suite/RAIL#railsdk-cpp)
**The C++ SDK** - Enable C++ applications to connect.

*   CMake-based build system
*   Loads `RailBridge.dll` via `LoadLibrary`
*   Callback-based command execution
*   Supports both x64 and x86 builds

**Build:**

build_x64.bat   # 64-bit
build_x86.bat   # 32-bit (legacy apps)

**Usage:**

Rail::ignite("MyApp", manifestJson, onCommand);

* * *

### RailSDK-Python

[](http://github.com/RAIL-Suite/RAIL#railsdk-python)
**The Python SDK** - Enable Python scripts to connect.

*   Uses `ctypes` to load `RailBridge.dll`
*   Decorator-based method registration
*   Simple API matching other SDKs

**Usage:**

from rail import RailEngine

engine = RailEngine()
engine.ignite([MyService()])

* * *

### RailSDK-Node (Never tested)

[](http://github.com/RAIL-Suite/RAIL#railsdk-node-never-tested)
**The Node.js SDK** - Enable TypeScript/JavaScript apps to connect.

*   Uses `ffi-napi` for native bridge access
*   TypeScript types included
*   Promise-based API

**Usage:**

import { RailEngine } from 'rail-sdk';
engine.ignite([new MyService()]);

* * *

### RailStudio

[](http://github.com/RAIL-Suite/RAIL#railstudio)
**The Visual Tool** - Scan and analyze applications.

*   EXE/DLL to analyzer
*   Auto-generates `rail.manifest.json`
*   Visualizes dependencies
*   Solution-wide scanning

**Use case:** Preparing legacy apps for Rail integration

* * *

### ConvertedProjectExample

[](http://github.com/RAIL-Suite/RAIL#convertedprojectexample)
Example applications showing SDK integration.

| Example | Description |
| --- | --- |
| `AgentTest` | Simple WPF app with customer database |
| `WorkflowDemo` | Workflow automation example |

**Manifest** Here you can find Manifest folder with all the "rail.manifest.json" already created for this example application

* * *

4. SDK Requirements for Developers
----------------------------------

[](http://github.com/RAIL-Suite/RAIL#4-sdk-requirements-for-developers)
When converting your application to be AI-controllable, here's exactly what you need:

### Requirements by Language

[](http://github.com/RAIL-Suite/RAIL#requirements-by-language)
| Language | What to Add | Automatically Included | Notes |
| --- | --- | --- | --- |
| **C# (.NET)** | `RailSDK.Universal.dll` | `RailBridge.dll` (auto-copied) | One reference, everything included |
| **C++ (Modern)** | `rail_sdk.dll` + `RailBridge.dll` | ‚Äî | RTTR reflection, auto method discovery |
| **C++ (Legacy)** | `rail_sdk.dll` + `RailBridge.dll` | ‚Äî | Custom dispatcher, manual routing |
| **Python** | `RailBridge.dll` + `rail` package | ‚Äî | Load via `ctypes` |
| **Node.js** | `RailBridge.dll` + `rail-sdk` npm | ‚Äî | Load via `ffi-napi` |

* * *

### C# Developers: One Reference Does It All

[](http://github.com/RAIL-Suite/RAIL#c-developers-one-reference-does-it-all)
When you add `RailSDK.Universal`, the native bridge is **automatically copied** to your output:

```
üìÅ bin/Debug/net8.0/
‚îú‚îÄ‚îÄ YourApp.exe
‚îú‚îÄ‚îÄ RailSDK.Universal.dll   ‚Üê You add this reference
‚îú‚îÄ‚îÄ RailBridge.dll          ‚Üê Copied automatically!
‚îî‚îÄ‚îÄ rail.manifest.json      ‚Üê You create this
```

**How to add:**

<PackageReference Include="RailSDK.Universal" Version="2.0.0" />

* * *

### C++ Developers: Two Options

[](http://github.com/RAIL-Suite/RAIL#c-developers-two-options)
C++ has **two integration modes** depending on your codebase:

#### Option A: Modern C++ with RTTR (Automatic Reflection)

[](http://github.com/RAIL-Suite/RAIL#option-a-modern-c-with-rttr-automatic-reflection)
For **new applications** or codebases that support C++17:

// Register your classes with RTTR macros
RTTR_REGISTRATION {
    rttr::registration::class_<OrderManager>("OrderManager")
        .method("CreateOrder", &OrderManager::CreateOrder);
}

// SDK auto-discovers methods
rail::RegisterInstance("OrderManager", &myManager);
rail::Ignite("MyApp");

**Files needed:**

```
üìÅ YourApp/
‚îú‚îÄ‚îÄ YourApp.exe
‚îú‚îÄ‚îÄ rail_sdk.dll            ‚Üê C++ wrapper (includes RTTR)
‚îú‚îÄ‚îÄ RailBridge.dll          ‚Üê Native IPC bridge
‚îî‚îÄ‚îÄ rail.manifest.json      ‚Üê Auto-generated
```

#### Option B: Legacy C++ with Custom Dispatcher (Manual Routing)

[](http://github.com/RAIL-Suite/RAIL#option-b-legacy-c-with-custom-dispatcher-manual-routing)
For **legacy applications** that can't use C++17 or RTTR (e.g., games, old codebases):

#define RAIL_NO_RTTR  // Disable RTTR

// Define your own command router
std::string MyDispatcher(const std::string& json) {
    if (json.find("MovePlayer") != std::string::npos) {
        MovePlayer();
        return "{\"result\": \"success\"}";
    }
    return "{\"error\": \"unknown\"}";
}

// Register and connect
rail::SetCustomDispatcher(MyDispatcher);
rail::Ignite("MyLegacyApp", "1.0", customManifest);

**Files needed:**

```
üìÅ YourApp/
‚îú‚îÄ‚îÄ YourApp.exe
‚îú‚îÄ‚îÄ rail_sdk.dll            ‚Üê C++ wrapper (no RTTR)
‚îú‚îÄ‚îÄ RailBridge.dll          ‚Üê Native IPC bridge
‚îî‚îÄ‚îÄ rail.manifest.json      ‚Üê You write this manually
```

> **Real Examples:** Notepad++ and Doom were integrated using Option B (Custom Dispatcher) because their codebases couldn't support RTTR.

* * *

### Python/Node.js Developers

[](http://github.com/RAIL-Suite/RAIL#pythonnodejs-developers)

```
üìÅ YourProject/
‚îú‚îÄ‚îÄ main.py (or index.ts)
‚îú‚îÄ‚îÄ RailBridge.dll          ‚Üê Copy manually
‚îî‚îÄ‚îÄ rail.manifest.json      ‚Üê You create this
```

Install the wrapper package that handles ctypes/ffi calls for you.

* * *

5. How Projects Connect
-----------------------

[](http://github.com/RAIL-Suite/RAIL#5-how-projects-connect)
[![Image 1: Architecture Overview](https://github.com/RAIL-Suite/RAIL/raw/main/Docs/Architecture_overview.jpg)](https://github.com/RAIL-Suite/RAIL/blob/main/Docs/Architecture_overview.jpg)

### Architecture Workflow

[](http://github.com/RAIL-Suite/RAIL#architecture-workflow)
[![Image 2: Architecture Workflow](https://github.com/RAIL-Suite/RAIL/raw/main/Docs/Architecture_workflow.png)](https://github.com/RAIL-Suite/RAIL/blob/main/Docs/Architecture_workflow.png)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    RailOrchestrator                       ‚îÇ
‚îÇ                    (Main AI Application)                    ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ  LLM APIs   ‚îÇ    ‚îÇ HostService ‚îÇ    ‚îÇ AssetService  ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  (Gemini,   ‚îÇ    ‚îÇ (Named Pipe ‚îÇ    ‚îÇ (Chip/Manifest‚îÇ   ‚îÇ
‚îÇ  ‚îÇ   OpenAI)   ‚îÇ    ‚îÇ   Server)   ‚îÇ    ‚îÇ   Discovery)  ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ                  ‚îÇ
          ‚îÇ         Named Pipe: "RailHost"
          ‚îÇ                  ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ               RailBridge.Native            ‚îÇ
    ‚îÇ            (C-ABI Native DLL)                ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ               ‚îÇ               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ RailSDK   ‚îÇ ‚îÇ RailSDK   ‚îÇ ‚îÇ RailSDK   ‚îÇ
‚îÇ .Universal  ‚îÇ ‚îÇ -Cpp        ‚îÇ ‚îÇ -Python     ‚îÇ
‚îÇ (C# Apps)   ‚îÇ ‚îÇ (C++ Apps)  ‚îÇ ‚îÇ (Python)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ               ‚îÇ               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Your C#   ‚îÇ ‚îÇ  Your C++  ‚îÇ ‚îÇ Your Python ‚îÇ
‚îÇ    App     ‚îÇ ‚îÇ    App     ‚îÇ ‚îÇ   Script    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Dependency Flow:

[](http://github.com/RAIL-Suite/RAIL#dependency-flow)

```
RailOrchestrator
    ‚îî‚îÄ‚îÄ uses ‚Üí RailSDK (RailFactory.Core) for manifest parsing
    
RailSDK.Universal
    ‚îî‚îÄ‚îÄ loads ‚Üí RailBridge.Native (DLL)
    
RailSDK-Cpp / RailSDK-Python / RailSDK-Node
    ‚îî‚îÄ‚îÄ load ‚Üí RailBridge.Native (DLL)

RailStudio
    ‚îî‚îÄ‚îÄ uses ‚Üí RailSDK (RailFactory.Core) for scanning
```

* * *

6. Usage Examples
-----------------

[](http://github.com/RAIL-Suite/RAIL#6-usage-examples)
### Example 1: Make a C# App AI-Controllable

[](http://github.com/RAIL-Suite/RAIL#example-1-make-a-c-app-ai-controllable)

// 1. Create your service
public class CustomerService
{
    public Customer GetCustomer(int id) => Database.Find(id);
    public void CreateCustomer(string name, string email) { ... }
}

// 2. Add one line in App.xaml.cs
protected override void OnStartup(StartupEventArgs e)
{
    base.OnStartup(e);
    RailEngine.Ignite(this);
}

// 3. Create rail.manifest.json (or use RailStudio)

### Example 2: Control a C++ Application

[](http://github.com/RAIL-Suite/RAIL#example-2-control-a-c-application)

// Define callback
const char* OnCommand(const char* json) {
    auto cmd = ParseJson(json);
    if (cmd.method == "MoveMachine") {
        Machine::Move(cmd.args["x"], cmd.args["y"]);
        return R"({"result": "OK"})";
    }
    return R"({"error": "Unknown"})";
}

// Connect
rail::ignite("CNCController", manifest, OnCommand);

### Example 3: Python Script Integration

[](http://github.com/RAIL-Suite/RAIL#example-3-python-script-integration)

class DataProcessor:
    def analyze_data(self, file_path: str) -> dict:
        return {"rows": 1000, "status": "processed"}

engine = RailEngine()
engine.ignite([DataProcessor()])
engine.wait()

### Example 4: Ask AI to Execute

[](http://github.com/RAIL-Suite/RAIL#example-4-ask-ai-to-execute)
With apps connected, ask in natural language:

```
"Create a customer named John Smith with email john@example.com"
‚Üí AI calls CustomerService.CreateCustomer("John Smith", "john@example.com")

"Move the machine to position X=100, Y=200"
‚Üí AI calls CNCController.MoveMachine(100, 200)
```

* * *

Quick Start
-----------

[](http://github.com/RAIL-Suite/RAIL#quick-start)
1.   **Run RailOrchestrator** - The main AI interface
2.   **Connect your app** - Add SDK and call `Ignite()`
3.   **Ask AI** - Natural language commands execute your code

* * *

**RAIL Protocol** - Bridging Legacy Applications and AI

---
*Ëá™Âä®ÈááÈõÜ‰∫é 2026-02-03*
